name: Show payload

on:
  push:
    branches:
      - '*'
env:
  builddockerimage: 'posledni'
  dockerregex: '(.{0,}/payload.yaml)|(.{0,}pretty.json)'
  dockerimagesarray: '["cross-builder"]'
jobs:
  show:
    runs-on: ubuntu-latest
    steps:
      - uses: octokit/graphql-action@v2.x
        id: get_latest_release
        with:
          query: |
            query($login: String!) {
              user(login:$login) {
                registryPackages(first:5, packageType:DOCKER) {
                  nodes {
                    name
                    packageType
                    versions(first: 5){
                      edges {
                        node {
                          platform
                          version
                          summary
                          readme
                        }
                      }
                    }         
                  }
                }
              }
            }    
          login: ${{ github.event.repository.owner.name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - run: "echo 'latest release: ${{ steps.get_latest_release.outputs.data }}'"

      - name: Create query
        run: |
          echo "
            query: 
              'query(\$owner: String!, \$repository: String!, \$querystr: String!) {
                repository(owner: \$owner, name: \$repository) {
                  registryPackagesForQuery(packageType: DOCKER, first: 100, query: \$querystr) {
                    nodes {
                      name
                      version(version: \"latest\") {
                        platform
                        sha256
                      }
                    }
                  }
                }
              }'
            variables:
              owner:
                type: arg
                name: owner
              repository:
                type: arg
                name: repository
              querystr:
                type: arg
                name: querystr
          " > dockerimagesingithubpackages.yaml

      - name: Query GitHub Packages registry for Docker images
        if: ${{ env.builddockerimage }} != 'true'
        uses: helaili/github-graphql-action@2.0.1
        id: get_debian_builders_data
        with:
          query: dockerimagesingithubpackages.yaml
          outputFile: q2.json
          logLevel: debug
          owner: cerna
          repository: cerna-testing-actions
          querystr: is:public machinekit-hal-debian-builder-v
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - run: "echo 'latest release: ${{ steps.get_debian_builders_data.outputs.queryResult }}'"
      - run: jq '.' q2.json
      - name: Try docker download
        run: |
          docker pull hello-world:latest &
          last_pid=$!
          echo "$last_pid"
          sleep 3
          EXITCODE=$(ps -ef | grep " $last_pid " | grep -v grep | awk '{print $2}')
          echo "$EXITCODE"
          if [ "$EXITCODE" == "$last_pid" ]; then
            kill -KILL $last_pid
            echo "Package exists in the registry"
          else
            echo "Package does not exist"
          fi

      - name: Show payload
        run: |
          jq '.' $GITHUB_EVENT_PATH
      
      - name: Install dotnet-script
        run: |
          dotnet tool install -g dotnet-script
          dotnet-script --version

      - name: Create csx
        run: |
          echo "
            #! /usr/bin/env dotnet-script
            #r \"nuget: Newtonsoft.Json, 12.0.3\"

            using System;
            using System.Collections.Generic;
            using System.IO;
            using System.Linq;
            using System.Text;
            using Newtonsoft.Json.Linq;
            public static bool IsNullOrEmpty(this JToken token)
            {
                return (token == null) ||
                       (token.Type == JTokenType.Array && !token.HasValues) ||
                       (token.Type == JTokenType.Object && !token.HasValues) ||
                       (token.Type == JTokenType.String && token.ToString() == String.Empty) ||
                       (token.Type == JTokenType.Null);
            }


            var strq = File.ReadAllText(\"./q2.json\");
            var ver = new List<string>() { \"amd64_10\" };
            JObject rss = JObject.Parse(strq);

            JArray packages = (JArray)rss[\"data\"][\"repository\"][\"registryPackagesForQuery\"][\"nodes\"];

            IList<string> packageNames = packages.Where(w => !w[\"version\"].IsNullOrEmpty()).Select(c => (string)c[\"name\"]).ToList();

            foreach (var i in packageNames)
            {
                System.Console.WriteLine(i);
            }

            var b = ver.All(name => packageNames.Any(pkg => pkg.Equals(\"machinekit-hal-debian-builder-v\" + name)));
            if (b)
            {
                System.Console.WriteLine(\"All packages present\");
            }
            else { System.Console.WriteLine(\"Not all packages present\"); } 
            " > script.csx
            chmod +x script.csx

      - name: Cat it 
        run: cat ./script.csx

      - name: Run the script
        run: |
          dotnet-script script.csx

      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "${{ env.GITHUB_CONTEXT }}"

      - name: Checkout the repo
        uses: actions/checkout@v2
        with:
          #ref: ${{ github.event.ref }}
          path: 'testing'
          fetch-depth: '0'

      - name: Test before ${{ github.event.before }}
        run: |
          if [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
            echo "This is new branch or tag push"
          fi

      - name: Check if Docker images related files were changed in this event
        if: github.event_name == 'push'
        env:
          DOCKER_REGEX: ${{ env.dockerregex}}
        run: |
          if [[ ${{ github.event.before }} =~ ^0+$ ]]; then
            printf "This is new branch or tag push\n"
            exit 0
          fi
          CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r ${{ github.event.before }} ${{ github.sha }})
          printf "Found changed files in this push:\n$CHANGED_FILES\n====\n"
          while IFS= read -r line; do
            if [[ $line =~ ${{ env.DOCKER_REGEX }} ]]; then 
              printf "Found file $line matching the regular expression for Debian builder files\n"
              echo ::set-env name=builddockerimage::true
              exit 0
            fi
          done <<< "$CHANGED_FILES"
          printf "No changes in Debian builder files were found, not going to force rebuild\n"
        working-directory: ./testing

      - name: State of builddockerimage
        run: |
          echo "${{ env.builddockerimage }}"

      - name: Show size
        run: |
          echo "${{ github.event.before }}"
          echo "${{ github.event }}"
          echo "${{ github.event.ref }}"
          echo "${{ github.ref }}"
          echo "${{ github.event.size }}"
          echo "$${{ github.event.size }}"
          echo $$${{ github.event.size }}
          echo "${{ github.event.push.size }}"
          echo "${{ github.event.push.*.size }}"
          jq '.commits | length' ${{ github.event_path }}

      - name: Run only
        run: |
          git diff-tree --no-commit-id --name-only -r ${{ github.event.before }} ${{ github.sha }} | xargs  
        working-directory: ./testing
      - name: Export changed
        id: filepath
        run: |
          echo ::set-output name=commitpath::$(git diff-tree --no-commit-id --name-only -r ${{ github.event.before }} ${{ github.sha }} | xargs)
        working-directory: ./testing
      - name: Show changed paths
        run: |
          echo ${{ steps.filepath.outputs.commitpath }}

      - name: Conditional run
        if: ${{ env.buildockerimage }} == 'true'
        run: |
          echo HELLO

  visible:
    runs-on: ubuntu-latest
    #needs: show

    steps:
      - name: Is variable exported?
        run: |
          echo "${{ env.builddockerimage }}"
